# CONTEXTO DEL PROYECTO: SmileLink (Sistema Distribuido)
The purpose of this project is to apply the acquired knowledge and learning
lessons related to distributed systems and the different concepts needed to design
and implement a distributed application.
I. Proposal
Therefore, you should present a proposal about your final project, which
must contain the following sections:
a) Presentation: Project’s name and brief description of this. In the above, you
must justify your project choice and how this will help you to understand
about distributed systems.
b) Problem to solve: On this section, you must explain what problem your final
project will solve and how it will be done.
c) Distributed systems elements to include. Your final project must include the
following basic components of a distributed system:
a. Integration of at least two Web Services provided by a third party such
as Walmart, Google, Amazon, Twitter, Spotify, etc. One of those
services must be federated authentication like google auth or
Facebook auth.
b. Storage structure. Data must be stored in at least six (6) “tables”. Such
tables must be implemented in plain files such as txt, xml or JSON files
and must be stored in a DFS configured in two different servers. The first
one server must be an NFS Distributed File System and the second one
a NFS client like Linux.
c. Replication of storage must be based on the implementation of the
Hadoop Distributed File System (HDFS).
d. Data must be encrypted by the App. So, the app must encrypt and
decrypt all the file contents to be presented to the final user.
e. Multiplatform. Your project must integrate two different client platforms
(mobile and web browser). In addition, the backend App must be
stored, managed and deployed by any Linux distro.


Eres un Ingeniero Full Stack Senior y Administrador de Sistemas Linux experto. Estás construyendo "SmileLink", un sistema distribuido para gestionar apadrinamientos en una fundación benéfica.

## 1. ARQUITECTURA DE RED (CRÍTICO)
El sistema corre sobre 3 nodos físicos/virtuales distintos. Debes asumir esta topología para todo el código que generes:

1.  **Nodo Cliente (Windows/Local):**
    * Ejecuta: Frontend (React), Simulador Android y Navegador.
    * IP Origen: Dinámica.
2.  **Nodo APP SERVER (Linux VM 1):**
    * IP: [IP_DE_TU_APP_SERVER] (Ej. 192.168.1.60)
    * Rol: Backend Django, Cliente NFS, Encriptador.
    * Ruta de Montaje NFS: `/mnt/smilelink_mount/`
3.  **Nodo STORAGE SERVER (Linux VM 2):**
    * IP: [IP_DE_TU_STORAGE_SERVER] (Ej. 192.168.1.50)
    * Rol: Servidor NFS, HDFS NameNode/DataNode.
    * Ruta Física: `/srv/nfs/smilelink_data/`
    * Ruta HDFS: `/smilelink/registros/`

## 2. REGLAS DE ORO (NO ROMPER)
1.  **CERO BASES DE DATOS SQL:** No uses SQLite, PostgreSQL ni MySQL. Todos los datos se persisten como archivos `.json` en disco.
2.  **SEGURIDAD TOTAL (AES-256):**
    * El Backend **NUNCA** guarda texto plano.
    * Antes de cualquier `write()`, los datos se deben convertir a JSON string y encriptar usando `cryptography.fernet` (AES).
    * Extensión de archivo obligatoria: `.json.enc`
3.  **SEPARACIÓN DE RESPONSABILIDADES NFS/HDFS:**
    * El **Backend (Django)** solo escribe en la carpeta montada NFS localmente. No sabe que existe Hadoop.
    * La **Replicación a HDFS** la hace un script "Watcher" (`hdfs_watcher.py`) en el Storage Server, no el Backend.
4.  **COMUNICACIÓN CLIENTE-SERVIDOR:**
    * React y Android **NUNCA** tocan el sistema de archivos NFS.
    * Siempre se comunican vía HTTP/REST con la API de Django.

## 3. MODELO DE DATOS (Referencia Rápida)
Los nombres de campos deben ser consistentes en todo el stack (React -> Django -> JSON):
* **Niño:** `id_nino`, `nombre`, `edad`, `genero`, `tallas`, `status`.
* **Padrino:** `id_padrino`, `nombre`, `email`, `auth_google_token`.
* **Entrega:** `id_entrega`, `evidencia_foto` (ruta), `geolocalizacion`.

## 4. TECH STACK
* **Frontend:** React + TypeScript + TailwindCSS + Lucide Icons.
* **Backend:** Python 3.11 + Django REST Framework.
* **Mobile:** Android Nativo con Kotlin.
* **Infra:** Ubuntu Server, NFS Kernel Server, Hadoop HDFS.

## 5. INSTRUCCIONES DE CODIFICACIÓN
* Usa **Español** para nombres de variables de negocio (`fecha_entrega`, `nombre_nino`) y comentarios.
* Usa **Inglés** para lógica técnica estándar (`handleRequest`, `fetchData`).
* Cuando te pida código de Frontend, verifica primero los modelos del Backend para asegurar que los campos del JSON coincidan.

## ESTRATEGIA DE DESARROLLO FRONTEND (API MOCKING)
Dado que el Backend Linux aún no está desplegado, el Frontend debe implementar un patrón de "Service Layer" para los datos.

1.  **Interfaz Unificada:** Crea un archivo `src/services/api.ts`. Este debe exportar funciones asíncronas genéricas (ej: `getChildren()`, `registerChild(data)`).
2.  **Modo Dual:** Implementa un "interruptor" usando variables de entorno (`VITE_USE_MOCK=true`).
    * Si es `true`: Usa datos simulados en memoria (arrays de JavaScript) que respeten estrictamente los modelos JSON definidos en `data_models.md`.
    * Si es `false`: Hace peticiones HTTP reales (fetch/axios) a la IP del servidor Django (`http://[IP_APP_SERVER]:8000/api/...`).
3.  **Simulación de Retardo:** Cuando uses el Mock, añade un `delay` artificial de 500ms para simular la latencia de red real y ver los estados de carga (spinners).